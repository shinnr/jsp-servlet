디자인 패턴(초급개발자가 몰라도 되지만 알아야하는 수많은 프로그래머들로부터 정제된 객체지향 프로그래밍 설계 노하우)
팩키지명_regular내 로직을통해 평범한 코드에서 발생될수있는 문제점을 인지하고
팩지키명_apply내 로직을통해 해당 디자인 패턴을 이해하도록 함.

1. Singleton Pattern 
   (실행 어플리케이션 내에서 특정 클래스의 인스턴스의 중복 생성을 억제하고,특정한 클래스의 단일 인스턴스화 제공)

2. State Pattern
   (특정 객체에 집중되어지는 조건분기문에서 분기조건의 증가에따른 코드량 증가를 막고 확장성을 제공하며 
     유지보수의 편리성을 제공함)
     
3. Pacade Pattern
   (순차적으로 처리되어야할 일련의 처리들을 통합 제공하기위한 인터페이스를 제공하여, 사용측에 해당 처리들의 활용 
      편리성을 제공함
      제공 인터페이스 : 1. 맥도날드 카운터(주문처가 집중되어져서 제공되며, 이후 주문음식을 만들기위해 처리되는 일련의
                                             처리는 주문자와 상관없이 백그라운드에서 이루어져 제공됨.)
                                        
                 2.iBatis SqlMapClient(사용측은 iBatis관련 라이브러리와 제공측에서 작성된 
                                SqlMapConfig.properties과 SqlMapConfig.xml 및
                                                다수 존재할수있는 mapper들의 정보를 기반으로 백그라운드단에서 작성된
                                SqlMapClient를 활용하여 쿼리를 질의할수있으며, DataBase 대상의
                                                컨넥션의 연결과 종료 및 일련의 트랜잭션 관리 등을 제공받을 수 있게됨.)
     
4. Strategy Pattern(State Pattern 포함)
   (상위 클래스와 하위 클래스들의 관계에서 하위 클래스들에 공통으로 활용이 필요로한 속성과 메서드는 상위 클래스들로부터
      상속을 통해 오버라이딩될수 있음.
      상속되어 구현된 하위 클래스들 중 특정 클래스가 상속된 메서드의 오버라이딩이 필요없는 상황에서 해당 메서드를 삭제할수
      없으며, 불필요한 메서드 선언이 존재할수밖에 없음.
      스트래티지[전략] 패턴을 활용해 불필요한 메서드 오버라이딩을 배제하고, State Pattern을 적용해
      동일한 메서드에서 다양한 오버라이딩 코드를 통해 서로 다른 코드 실행과 알고리즘의 확장을 제공함.)
                               
5. Adapter Pattern
   (A사가 제작한 컴포넌트와 B사가 제작한 컴포넌트는 서로 다른 팩키지의 클래스로 설계되어 제공되어지며,
    A사의 컴포넌트와 B사의 컴포넌트와의 연동을위한 아답터 클래스를 작성할수 있으며, A사 및 B사의 컴포넌트 원본 자체를
      회손하지 하지않으면서 각 컴포넌트별 확장된 기능을 추가할 수 있음.)
      
6. Factory Pattern(클래스 생성 및 제공 코드가 집중되어있는 클래스로 팩토리 클래스를 통한 확장성에 집중함.)
       장점 - 1). 산재되는 다양한 클래스 생성 코드(new)가 집중 관리될수있으며, 중복되는 생성 코드를 제거할수있음.
	      2). 활용처에 제공되는 단편적인 정보를 통해 팩토리 클래스 백그라운드단의 모든 클래스 및 코드들을
	               캡슐화 할수있음.
	      3). 구현체가 제공 서비스가 아닌 인터페이스 기반 서비스를 제공하므로 활용처에 유연성과
	               확장성을 제공함.
	                   
   1).Factory Method Pattern : 동일한 interface를 구현한 다양한 구현클래스의 인스턴스를 팩토리
                                             클래스를 통해 인스턴스를 반환함.
                                             활용처는 제공된 메뉴얼에따라 팩토리 클래스에게 자원을 요청 취득 후 활용. 
    
   2).Abstract Factory Pattern : 산재되어있는 다수의 클래스들을 활용처의 다양한 요구를 토대로
                                             개별 그룹으로 정의 생성 관리하여 각각의 요구에 맞춰 자동화시켜 활용성을
                                             극대화 시킴.  
                                             
7. Observer Pattern
   (특정 객체의 특정 상태 변경시 해당 객체에 의존성을 갖는 다른 객체들에게 상태 변경이 전파되어 코드 반영이 이루어지며,
    1:1 or 1:N 형태를 띠울수 있고, :1 or :N의 존재를 옵저버 객체라고 불림.
      상태 변경시 옵저버 객체에 상태 변경을 전파하는 객체 1:을 서브젝트 객체라고 함.) 
                                       
8. Decorator Pattern(기능의 확장에는 열려있고, 코드의 수정은 닫혀있어야함.)
   (이미 정의되어있는 클래스의 내부에 동적으로 정의된 기능을 추가 또는 삭제하기위해 활용됨.)
   
9. Telescoping Constructor Pattern(생성자 주시 패턴)
   (특정 객체 생성시 다양한 형태로 초기화되어야하는 패턴을 생성자를 통해서 구현.)   
   
10. JavaBeans Pattern
   (특정 객체내 전역변수가 선언되고, 각각의 전역변수의 setter를 통해서 값을 설정함.
      해당 객체의 생성자는 파라메터가 선언되어있지않은 디폴트 생성자를 통해 객체화됨.)
    
11. Builder Pattern
   (9.항과 10.항을 결합하여 활용하고, 객체의 인스턴스화 시점에 수행되어야하는 복잡한 초기설정을 특정 객체에 전담시켜 활용함.)
   
12. Proxy Pattern
   (인스턴스화한 특정 객체에 접근시에 대한 권한 검증 또는 특정 객체의 로직 처리를 대리하는 객체를통한 객체 보호)

13. FlyWeight Pattern - 예제 없음
   (공유되어야하는 값을 가진 객체를 공유할수 있는 환경하에서 활용되도록 함.)
       

   
